<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta content="telephone=no,email=no" name="format-detection"/>
	<title>let</title>
</head>
<body>
generator函数又称生成器函数
Generator函数用function*声明。

<script>
 function * hello(name) {
	 yield `他的名字叫${name}`;
	 yield '123';
	 yield '你好';
 }
 let v = hello("张三")			//Generator函数被调用后得到的生成器理解成一个遍历器iterator，用于遍历函数内部的状态。
	console.log(v.next())		//{value: "他的名字叫张三", done: false}
	console.log(v.next())		//{value: "123", done: false}
	console.log(v.next())		//{value: "你好", done: false}
	console.log(v.next())		//{value: undefined, done: true}

</script>
generator函数的行为
通过上面的案例，我们知道了：Generator函数被调用后并不会一直执行到最后，它是先返回一个生成器对象，然后hold住不动，
等到生成器对象的next( )方法被调用后，函数才会继续执行，直到遇到关键字yield后，又会停止执行，并返回一个Object对象，
然后继续等待，直到next( )再一次被调用的时候，才会继续接着往下执行，直到done的值为true。

yield 作用
而yield在这里起到了十分重要的作用，就相当于暂停执行并且返回信息。有点像传统函数的return的作用，
但不同的是普通函数只能return一次，但是Generator函数可以有很多个yield。
而return代表的是终止执行，yield代表的是暂停执行，后续通过调用生成器的next( )方法，可以恢复执行。

next()方法可以接受参数
此外next()方法可以接受一个参数，它的参数会作为上一个yield的返回值；

总结：Generator函数是一种特殊的函数，可以使用关键字yield和next( )实现暂停和继续执行，而关键字yield*专门用于调用Generator函数，看似简单的特性，在实际开发中却有极大的用处。
</body>
</html>