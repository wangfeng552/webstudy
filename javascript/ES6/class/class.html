<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta content="telephone=no,email=no" name="format-detection" />
	<title>let</title>
</head>

<body>
	<div class="mk"></div>

	<script>
		//class定义了一个“类”，
		class Animals {
			//这就是构造方法，而this关键字则指向该类实例化后的对象
			constructor() {
				//定义方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实力对象可以共享的
				this.name = "dog";
				this.showMessage = function (a) {
					alert(a)
				}
			}
			says(say) {   // 3.类的所有方法都定义在类的prototype属性上面。
				console.log(this.name + 'is' + say)
			}
		}

		// 3.等同于
		Animals.prototype = {
			showName() {
				console.log(123)
			}
		}

		let animal = new Animals()
		animal.says("50kg") // 4.在类的实例上面调用方法，其实就是调用原型上的方法。  animal.constructor === Animal.prototype.constructor

		// 5.由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便的一次向类添加多个方法
		Object.assign(Animals.prototype, {
			showAge() { },
			showSex() { }
		})

		// 6. prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。
		Animals.prototype.constructor === Animals
	</script>
</body>

</html>