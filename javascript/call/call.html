<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>call/apply</title>
</head>
<body>
call() 调用一个对象的方法，用另一个对象来替换当前对象；
<!--案例一-->
<script>
	function add(a,b){
		alert(a+b)
	}
	function sub(a,b){
		alert(a-b)
	}
	add.call(sub,1,2)		// ==add(1,2)  用add来替换sub
							//函数其实是对象，函数名是对 Function 对象的引用
</script>

<!--案例二-->
<script>
	function Animal(){
		this.name="Animal";
		this.showName=function(){
			alert(this.name)
		}
	}
	function Cat(){
		this.name="Cat";
	}
	var animal=new Animal();
	var cat=new Cat();
	animal.showName.call(cat)
//	call 的意思是把 animal 的方法放到cat上执行，原来cat是没有showName() 方法，现在是把animal 的showName()方法放到 cat上来执行，所以this.name 应该是 Cat
</script>

<!--案例三 实现继承-->
<script>
	function People(name){
		this.name=name;
		this.showName=function(){
			alert(this.name);
		}
	}
	function Cat(name){
		People.call(this,name)
	}
	var xz=new Cat("张三");
	xz.showName()
// People.call(this) 的意思就是使用 People对象代替this对象，那么 Cat中不就有People的所有属性和方法了吗，Cat对象就能够直接调用People的方法以及属性了.
</script>

<!--案例四 多重继承 使用两个 call 就实现多重继承了-->
<script>
	function a1(x,y){
		this.x=x;
		this.y=y;
		this.showSub=function(){
			alert(this.x-this.y)
		}
	}
	function a2(x,y){
		this.x=x;
		this.y=y;
		this.showAdd=function(){
			alert(this.x+this.y)
		}
	}
	function a3(x,y){
		a1.call(this,x,y)
		a2.call(this,x,y)
	}
	var ta=new a3(2,5)
	console.log(a3.showSub())
	console.log(a3.showAdd())
</script>
</body>
</html>