<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML5History</title>
</head>

<body>
    History interface 是浏览器历史记录栈提供的接口，通过back()、forward()、go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。

    从 HTML5开始，History interface 提供了2个新的方法：pushState()、replaceState() 使得我们可以对浏览器历史记录栈进行修改：

    window.history.pushState(stateObject,title,url)
    window.history.replaceState(stateObject,title,url)

    stateObject：当浏览器跳转到新的状态时，将触发 Popstate 事件，该事件将携带这个 stateObject 参数的副本
    title：所添加记录的标题
    url：所添加记录的 url


    这2个方法有个共同的特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础

    1.push //与hash模式类似，只是将window.hash改为history.pushState
    2.replace //与hash模式类似，只是将window.replace改为history.replaceState
    3.监听地址变化 //在HTML5History的构造函数中监听popState（window.onpopstate）

    ---------------------------------------------------------------------------------------

    两种模式比较
    pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL

    pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串

    pushState可额外设置title属性供后续使用

    history模式则会将URL修改得就和正常请求后端的URL一样,如后端没有配置对应/user/id的路由处理，则会返回404错误
</body>

</html>